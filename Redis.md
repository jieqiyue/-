# redis缓存穿透、缓存击穿、缓存雪崩区别和解决方案

#### 缓存雪崩：

在某一个时刻，redis key全部失效，导致所有请求都直接打到数据库mysql上。导致mysql挂掉。和缓存击穿不同的是，缓存击穿是好多请求都请求同一个key。

**解决方案**：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3. 设置热点数据永远不过期。

#### 缓存穿透

**描述：**

​    缓存穿透是指**缓存和数据库中都没有的数据**，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

 **解决方案：**

| **接口层增加校验**，如用户鉴权校验，id做基础校验，id<=0的直接拦截； |
| ------------------------------------------------------------ |
| 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为**key-null**，**缓存有效时间可以设置短点**，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 |

布隆过滤器

#### 缓存击穿

至于**缓存击穿**嘛，这个跟**缓存雪崩**有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

# aof和rdb

这两种是在服务器宕机的情况下出现的方案。都是为了避免将丢失的数据从mysql中重写读入redis。（如果redis用作缓存的话）都是通过aof文件或者rdb文件来将数据恢复。

- aof

aof的特性

1. 先执行命令，再去写aof文件。这样的好处是不用提前检查语句语法是否正确。因为能够执行成功，那么就可以视为这条语句没有语法错误。
2. redis保存的是执行的命令，而不是key/value数据。
3. 如果在执行完毕一条命令的时候，刚刚好这个时候服务器宕机，那么还没来得及写入磁盘aof文件中，那么这条数据将会丢失。
4. 写aof日志文件的操作是在redis主线程中进行的，所以，如果频繁的执行aof操作，会影响性能。

> 配置

 redis.conf 配置文件的 APPEND ONLY MODE 下：

```text
appendonly yes  // 将这里改为yes
```

> aof 落盘策略

\# appendfsync always

appendfsync everysec

\# appendfsync no

以上三种策略，no代表由操作系统来决定何时将缓冲区中的数据同步到磁盘上去。另外两个分别是每秒同步一次和每执行一条命令就同步一次。当然，每秒同步一次的策略一般不会用。一般我们都会使用everysec。

那么，这三种策略到底有什么区别呢？

如果要追求极致的数据高可靠性，那么就选择always方案。每次执行一条语句就立马写aof文件。这样最多就是丢失一条语句记录。如果要追求极致的性能，则选择no方案。由操作系统决定啥时候写aof文件。

> aof重写机制（bgrewriteaof 命令）

1. aof重写就是说，aof文件如果太大了的话，那么第二次启动，将会把aof文件中每一条语句都执行一遍，那么是相当耗时的。
2. 那么就需要重写。所谓重写，就是说，我把数据的最终状态用一条语句来表示，这样就避免了对于同一个key执行那些中间步骤。
3. 这个重写要注意的一点就是，重写不是根据aof文件来进行重写的，是根据当前redis中的数据来进行重写一个新的aof文件来替换原来的aof文件。
4. 重写并不会阻塞主线程。是由主线程fork出来的子线程进行的。
5. 子进程在进行 AOF 重写期间，服务器进程依然在处理其它命令，这新的命令有可能也对数据库进行了修改操作，使得当前数据库状态和重写后的 AOF 文件状态不一致。为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。这样将 AOF 重写对服务器造成的影响降到了最低。

- rdb

所谓rdb就是给内存的某一个时刻做一个快照。有两个命令可以使用save和bgsave。bgsave是fork出一个子进程来进行操作。这个子进程可以共享父进程中的数据。如果是save命令，那么会在主进程中来进行。那么，就会阻塞后续的操作。

bgsave命令虽然不会阻塞主进程，但是fork是需要时间的。所以频繁的进行bgsave命令照样会使主进程经常阻塞。并且，占用大量磁盘io。那么，在进行快照的时候，主线程是否能写呢？是能够的。使用了cow，写时复制技术。

cow技术就是说，在fork出子进程之后，子进程和父进程映射到同一段物理内存。然后这一段物理内存被置位为read-only。当某个进程有写的操作的时候，就会将这个内存页给复制一份到两个进程中。这样的话，好处就是不用一开始fork的时候就去复制所有内存页。只有当有要写的内存页的时候才去复制。

Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。可以通过参数配置。

# Redis是单线程的，为什么还是这么快？

首先明白一点，单线程指的是redis中的主线程。持久化、异步删除、集群数据同步等功能是由其他线程而不是主线程来执行的。严格来说，redis并不是纯粹的单线程处理所有事情。

redis之所以快，是因为在 Redis 只运行单线程的情况下，select/epoll 机制，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个IO 流的效果。

select/epoll 一旦监测到 套接字 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis 的响应性能。

# 主从库时如何实现数据一致的？

![image-20210209213440154](C:/Users/Jieqiyue/AppData/Roaming/Typora/typora-user-images/image-20210209213440154.png)

主从复制的作用主要包括：

- **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
- **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
- **高可用基石**：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

https://www.cnblogs.com/cooffeeli/p/redis_master_slave.html

复制过程主要分为全量复制和部分复制。从节点会判断这次是否要全量复制还是部分复制。如果要部分复制从节点会发送psync {runid} {offset}给主节点。主节点也会判断是否能进行部分复制。如果主从节点断开时间比较长，主节点执行的命令已经超过主节点的缓冲区中的容纳量了，那么主节点不予理会从节点的部分复制要求。转而进行全量复制。

# 主库挂了，怎样不间断的服务？

哨兵机制。哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。![image-20210210103056307](C:/Users/Jieqiyue/AppData/Roaming/Typora/typora-user-images/image-20210210103056307.png)

1. 怎样监控主库下线呢？

   在哨兵集群中有超过半数（可以配置）的哨兵都认为主库ping不通了，那么可以认为主库已经挂了。

2. 怎样选择新主库呢？

   从剩下没有断连的从库中，选择一个网络环境好的，并进行打分（打分依据：从库优先级、从库复制进度以及从库 ID 号）。在某轮打分中，有一个从库胜出那么这个从库将会被选为主库。

# 当哨兵挂了，主从库还可以切换吗

哨兵直接的发现通过向主库注册同一个频道，通过pub/sub机制，哨兵之间建立集群。哨兵通过info命令获取从库的信息，和从库建立连接。

# redis 中的 lfu 算法

在 redis 中，lfu算法并不是严格的lfu算法。而是一种特殊的实现。首先，redis 会在redisObject 中存放每一个Object 的 lfu 时间戳。然后，在需要进行lfu算法的时候，去整个 redis 中挑选一部分对象加入到集合中，然后从这个集合中选择最小的lfu时间戳来进行删除。而后，如果还要进行lfu算法的话，只会去寻找新的 Object 来加入这个集合，并进行判断再删除。

# Redis 基本数据类型底层实现原理

https://xie.infoq.cn/article/98c984f6462aec99ffc0c3b42

> String 

SDS 全称 Simple Dynamic String，即简单动态字符串。SDS 组成部分如下：

![img](https://static001.geekbang.org/infoq/30/301e68c6ae5f6475d8dd09cd7a89ae90.png)

- **free：表示 buf 中的空闲的空间大小，图左空闲空间为 0，图右空闲空间为 3**
- **len：表示 buf 中的内容长度，注意 len 的长度不包括 ' \0 '（字符串以\0 结尾是为了使用 C 语言中现成的库函数，而不需要重新造轮子）**
- **buf：一个 char 类型的数组，用于存储实际字符串的内容。**

优点：

1. 二进制安全：

   二进制安全的意思就是，能够把字符串给完整的读取出来。因为 c 语言原本的字符串遇到空字符串就会停止读取。这样就导致当存入的字符串中有空格的话，就不能完整的读取。那么 Redis 中使用 SDS 已经提前标识了该字符串的长度。就能够完全把字符串给读取完整。所以，简单来说，二进制安全就是，字符串不是根据某种特殊的标志来解析的，无论输入是什么，总能保证输出是处理的原始输入而不是根据某种特殊格式来处理。

>  List

在 Redis3.2 之前，List 底层采用了 ZipList 和 LinkedList 实现的，在 3.2 之后，List 底层采用了 QuickList。

Redis3.2 之前，初始化的 List 使用的 ZipList，List 满足以下两个条件时则一直使用 ZipList 作为底层实现，当以下两个条件任一一个不满足时，则会被转换成 LinkedList。

- **List 中存储的每个元素的长度小于 64byte**
- **元素个数小于 512**

#### ZipList :  

一段连续的存储空间组成。类似于数组。在中间插入或者删除一个元素时，在插入或删除位置后面的元素可能都需要发生相应的移动操作。

### LinkedList：

是由一系列不连续的内存块通过指针连接起来的双向链表。

![img](https://static001.geekbang.org/infoq/4b/4b35fc9cf0145bdcd6af0b07a02c796e.png)

### QuickList :

QuickList 其实就是结合了 ZipList 和 LinkedList 的优点设计出来的。

各部分作用说明：

- **每个 listNode 存储一个指向 ZipList 的指针，ZipList 用来真正存储元素的数据。**
- **ZipList 中存储的元素数据总大小超过 8kb（默认大小，通过 list-max-ziplist-size 参数可以进行配置）的时候，就会重新创建出来一个 ListNode 和 ZipList，然后将其通过指针关联起来。**

![img](https://static001.geekbang.org/infoq/d1/d1ebb253e429665da1d360a541f07e3e.png)

> set

intset我们可以理解为数组，这个数组是有序排列的。hashtable就是普通的哈希表（key为set的值，value为null）

set的底层存储intset和hashtable是存在编码转换的，使用**intset**存储必须满足下面两个条件，否则使用hashtable，条件如下：

- 结合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过512个

> zet

## 面试题

### 怎样让某一些数据永久不被淘汰

数据的淘汰策略在redis中有八种。我们需要选择 volatile-lru 策略。该策略含义是：对于设置了过期时间的数据使用 lru 算法进行淘汰。那么，我们可以将那些要永久存放在 redis 中的数据不要设置过期时间。那么在缓存满了之后就不会去淘汰这一部分数据。

### 怎样选择缓存淘汰策略

先根据是否有始终会被频繁访问的数据（例如置顶消息），来选择淘汰数据的候选集，也就是决定是针对所有数据进行淘汰，还是针对设置了过期时间的数据进行淘汰。候选数据集范围选定后，建议优先使用 LRU 算法，也就是，allkeys-lru 或volatile-lru 策略。

当然，设置缓存容量的大小也很重要，我的建议是：结合实际应用的数据总量、热数据的体量，以及成本预算，把缓存空间大小设置在总数据量的 15% 到 30% 这个区间就可以。

