- 架构：Server 层，引擎层（缓存，连接器，分析器，优化器，处理器）
- 引擎：InnoDB，MyISAM，Memory 区别
- 聚簇索引，非聚簇索引区别（从二叉平衡搜索树复习（AVL，红黑树）到 B 树，最后 B+树）
- MySQL、SQL 优化方法
- 覆盖索引，最左前缀匹配
- 当前读，快照读
- MVCC 原理（事务 ID，隐藏字段，Undo，ReadView）
- Gap Lock、Next-Key Lock、Record Lock
- 三大范式



### 索引

索引可以让服务器快速地定位到表的指定位置。但是这并不是索引的唯一作用。根据索引的数据结构的不同，还有其它的一些作用。

某些索引的优点：

1. 随机io到顺序io

2. 减少了服务器需要扫描的数据量
3. 可以帮助服务器避免排序和生成临时表

| Storage Engine                                               | Permissible Index Types            |
| :----------------------------------------------------------- | :--------------------------------- |
| [`InnoDB`](https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html) | `BTREE`                            |
| [`MyISAM`](https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html) | `BTREE`                            |
| [`MEMORY`](https://dev.mysql.com/doc/refman/5.7/en/memory-storage-engine.html)/`HEAP` | `HASH`, `BTREE`                    |
| [`NDB`](https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html) | `HASH`, `BTREE` (see note in text) |

> hash 索引

hash索引在mysql中的innodb存储引擎并没有显式的支持。只有memory引擎显式的支持。在innodb中，hash索引是由存储引擎根据索引的使用概率来自动生成的。所以innodb的hash索引页叫做“自适应哈希索引”。

hash索引也有一些优点和缺点：

1. Hash索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。哈希索引只支持等值比较查询，包括**＝、 IN 、<=>** (注意<>和＜＝＞是不同的操作）。 也不支持任何范围查询，例如WHERE price > 100。　　
   由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，**因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。**
2. Hash索引无法被用来避免数据的排序操作。　　
   由于Hash索引中存放的是经过Hash计算之后的Hash值，**而且Hash值的大小关系并不一定和Hash运算前的键值完全一样**，所以数据库无法利用索引的数据来避免任何排序运算;
3. Hash索引不能利用部分索引键查询。　　
   对于组合索引，**Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值**，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。
4. Hash索引在任何时候都不能避免表扫描。　　
   前面已经知道，**Hash索引是将索引键通过Hash运算之后，将 Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中**，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
5. **Hash索引遇到大量Hash值相等的情况后性能并不一定就会比BTree索引高**。　
   对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

> b-tree索引

虽然叫b-tree索引，但是，在innodb中的实现是用b+tree实现的。在这种索引中，是通过从根节点，一层层往下来寻找的。在叶子节点中能够找到就有，没有找到就没有。

b-tree的一大特点就是索引的列的值都是按顺序存储的。并且每一个叶子页到根的距离相同。这种特点就很适合来查找范围数据。但是要注意的一点是要满足最左前缀原则。

> 聚簇索引

聚簇索引其实并不是一种新的索引。而是数据的一种组织结构。它将将数据存储与索引放到了一块，找到索引也就找到了数据。在聚簇索引的叶子节点中，存放了整行的数据。如果找到了叶子节点，也就找到了数据行。还有一个很重要的特性就是：聚簇索引中的叶子节点是按照主键的增大顺序排列的。所以，聚簇索引也适合做范围查询。这个聚簇索引有点像一个已经排序好的数组。

聚簇索引**默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键**来作为聚簇索引。

> 非聚簇索引（二级索引）

所谓辅助索引，也就是二级索引。它的叶子节点上存放的是聚簇索引的值（主键的值）。而不是主键的指针。在要获取一条数据的时候，如果通过二级索引获取的话，是先在二级索引的b-tree中获取到叶子节点上的主键值，再去聚簇索引中找到这个主键值对应的数据行（在叶子节点上）。所以，需要两次访问。

MyISAM中没有聚簇索引。主键索引和非主键的索引都是一样的结构。它们的叶子节点都是指向实际数据的指针。也就是说它们的数据时存放在另外一个地方的。

> 覆盖索引

覆盖索引指的就是索引的叶子结点已经包含了需要查询的数据，这样就没必要根据主键进行二次回表查询，显然覆盖索引效率更高一些。

> 唯一索引和普通索引

它们两者都能够实现相同的功能，都是索引。

查询操作的时候，两者几乎相同。

在更新操作的时候，普通索引会先写 change buffer 然后在下次要访问那个数据页的时候（读入内存的时候）再去把 change buffer 中的修改到数据页中。而唯一索引因为需要判断唯一性，所以用了 change buffer反而更加的低效。

>  前缀索引

对于一个字符串，比如说邮箱。我们可以使用前缀索引，这样的话占用的空间更小。但是有可能回表查询的次数会增多。所以，我们需要谨慎选择前缀索引的长度。尽量选择到一个最佳的长度。

前缀索引对于覆盖索引也会有影响。覆盖索引中，如果where条件中用到是前缀索引的话，那么innodb会回表去聚簇索引中重新查询。就是简单的说，前缀索引可能会使覆盖索引失效。

那么在前缀索引中，如果我们存放的是身份证号码这种。要怎样提高索引的使用效率呢？

我们可以将身份证号码倒序存储。提高前缀索引的区分度。或者是自己再去加一行hash字段。然后把这个hash字段建立索引。这样的索引只需要四个字节。然后在插入的时候用一个存储过程将这一列给填上。比较的时候记得要精确比较身份证号码。

> 联合索引

语法：**create index indexName on  tableName(column1,column2,...,columnN)**，如create idx_un_userid_username on user(id,name)

联合索引也是要遵循最左前缀原则的。建立联合索引的话，可以使得某些查询不用回表。

### 索引失效的情况

1. 索引无法存储null值。当where语句中有is null 的时候，不会使用索引。
2. 优化器认为全表扫描访问的数据块少一些，扫描的行数少一些，那么就会执行全表扫描。就比如说建立索引的那个列的区分度很低。
3. 没有按照最左前缀原则。在where中有like %三，这种语句。那么开头不知道要用什么开头，是不会走索引的。
4. 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
5. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

### mysql中一条语句是怎么执行的

![image-20210206183216687](C:/Users/Jieqiyue/AppData/Roaming/Typora/typora-user-images/image-20210206183216687.png)

会经过几个阶段。一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。调用存储引擎的接口，逐个遍历得到满足的结果，放入结果集中。

### redo log和binlog

binlog是server层实现的，没有crash-safe的能力。redo log 是循环写的，空间固定会用完。

redo log是innodb特有的日志。有crash-safe的能力。binlog 是可以追加写入的。

Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容。

这里的redo log就是说，我在更新某一条数据的时候，从磁盘上读入到内存中来了。然后修改内存中的那条要修改的数据。然后就要写回磁盘。这个时候由于我们引入了redo log。那么，我们先写入redo log。等系统不繁忙的时候，再去刷回磁盘。那么redo log也是写磁盘为什么就比直接将内存中修改后的数据写回磁盘快呢？同样都是些磁盘，但是写redo log 只需要顺序写就行了。而另外那种写入磁盘，可能会面临分页，不顺序io等。所以这样看来，redo log 确实性能更好。但是当redo log 缓冲区写满了之后， 那么就只能去将缓冲区中的一部分页的修改写入磁盘了。

1. undo  log 是在内存中记录的逻辑修改。当内存中的undo log buffer中有需要的数据的时候，回去buffer中进行查询。undo log 也用来实现MVCC。

   **undo log  ======>  原子性**

2. **redo log  =======> 持久性  =======> 使用redo log 提高性能** 

![img](https://pic2.zhimg.com/80/v2-41365bae03d3607ea95ff74246356a99_720w.jpg)

mysql支持三种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数配置。有三种配置。因为在内存中有redo log buffer，一般来说内存中的数据要存入磁盘需要先写入OS buffer，然后在刷入磁盘上。

https://cloud.tencent.com/developer/article/1415191

### ACID 特性

Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性。

这四个特性是数据库事务必须具备的四个特性。

https://www.jianshu.com/p/d396fffaceb6

### MVCC

MVCC是一种并发控制的方法，主要是为了提高数据库读写性能。实现读-写冲突不加锁。

innodb中的实现大致是通过在每一行记录后面增加两个隐藏列来实现的。一个列是创建时间一个列是修改时间。当然，这两个列存的是版本号。每开启一个事务，版本号都要加一。在不同的隔离级别下，MVCC的工作是不同的。如下，是在可重复读的隔离级别下的实现：

比如说select语句。就是通过读取行的删除版本号和自己比较。要晚于我的事务的版本号。并且创建版本号要早于自己的版本号，满足这两个条件才会被读出来。

https://www.jianshu.com/p/8845ddca3b23

### 隔离级别

https://blog.csdn.net/u010960184/article/details/82557978

###  锁

分为表锁和行锁。比如一个事务在修改某一条记录的时候，如果where条件中的列是唯一索引的列，那么只会锁住这一行。如果是where条件中的列没有加上索引的话，那么就会用表锁。并且还不能插入数据。

还有当前读和快照读。普通的读操作是快照读。而下面这些是当前读。当前读会锁住记录。这里的这些当前读也分为表锁和行锁。跟上面一样，取决于where后面的列是否有唯一索引。

select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;

>  全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。使用了之后，所有语句都会被阻塞。除了查询语句。这种全局锁一般是用在某些对于不支持MVCC可重复读隔离级别的存储引擎中的。

> 表锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

对于innodb这种引擎来说，一般不会显式的去加一个表锁。因为有更细粒度的锁。

那么MDL 这种锁是我们无法控制的。是由于MySQL自动给我们加的。它也用了读写分离的思想。读与读获取到的是MDL读锁，相互不会阻塞。如果出现了 DDL（修改表结构的语句，注意不是增删改查语句）语句的话，就需要先获得MDL写锁。在这个写锁获取的时候，读操作是不能进行的。事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

> 行锁（在存储引擎层实现）

对于没有行锁的存储引擎来说，并发修改只能锁整张表了。innodb是有行级锁的。如果有两个事务对同一行数据进行修改，那么只能等一个事务完成后另一个才能去修改。

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

![image-20210208115412145](C:/Users/Jieqiyue/AppData/Roaming/Typora/typora-user-images/image-20210208115412145.png)

根据上面的这个协议，我们写SQL的时候就可以尽量的把可能造成行锁冲突的语句放在比较后面去执行。这样，行锁冲突的时间就减少了。

> 死锁和死锁检测

当一个线程被阻塞的时候，MySQL会自动的去检测是否发生了死锁。那么如果是上面那种情况的话，你被阻塞其实不是由于死锁。而是发生了行锁。那么这个死锁检测就是没什么用的。反而会耗费大量的CPU资源。因为大量的CPU都用来检测是否死锁了。导致并发度下降。那么我们可以采取一些办法，最简单的就是去关闭死锁检测。或者减少并发度。或者可以考虑通过将一行改成逻辑上的多行来减少锁冲突。

> 隔离级别的实现

MVCC实现可重复读的话是依靠行数据有多个版本。每个版本都有自己的版本号。而事务在开始的时候也有一个版本号。我们就可以通过这个事务开启的时候的版本号和行数据的历史版本号来实现可重复读的。这里还有一个要注意的重点是：当前读！当前读的意思是在一个事务中，如果你要去修改某一行的数据的话，一定是去读取最新的数据的。即使你是在可重复读的隔离级别下面。这个一定要去读取最新数据的意思是，读取已经提交了的事务的数据。

比如说现在是可重复读的隔离级别。然后有A，B两个事务。B事务先对x记录进行了x.id = 999 的修改。并且提交了。那么，此时如果A去读的话，是不能够读到这个999的，但是如果此时A事务对这条记录进行更新操作那么，就是用这个999来进行更新的。也就是说A能够读到999，这就是当前读。

### MySQL优化




### 面试题

#### mysql 内连接外连接

https://blog.csdn.net/plg17/article/details/78758593

####  为什么二级索引的叶子节点中要存放主键的值，而不是指针？

因为如果存放的是指针的话，当聚簇索引有分页或者合页的时候，指针的值就要改变了。那如果仅仅只是存放值的话，在页发生改变的时候就不用去改这个二级索引叶子节点中的值了。更加方便。

#### 为什么二级索引中的叶子节点不存放行数据

可以存放行数据。但是这样的话导致冗余数据太多了。如果你有多个二级索引的话，那么你一个表就得存好几份数据。

#### 数据库事务实现原理

要说数据库事务的原理，得先知道数据库事务提供了什么。事务提供了可靠性（crash时前后数据一致保证），并发性（多个事务同时开启保证不互相影响）。

实现：redo log 是用来恢复数据的。如果在事务提交之后数据库crash了，那么可以通过redo log 来实现数据的恢复。因为在innodb中，数据不是直接写到磁盘里面去的，而是先写到内存中的Buffer Polol中的。当数据库空闲的时候再去写入到磁盘。那么，如果在将数据写入到内存中之后，还没来得及写入磁盘，这个时候crash了，那么就可以使用redo log  来恢复数据。因为redo log是先行写入磁盘的。redo log 虽然也是写磁盘，但是是顺序io，比直接将数据写入到真正的数据页上更加的快速。undo log 是用来实现当提交事务之前数据库crash了，那么可以回滚到之前的状态。这个undo log 是先于数据持久化到磁盘上的。日志先行的原则。MVCC用来实现数据库在读的时候的隔离性。

总结

实现事务采取了哪些技术以及思想？

- 原子性：使用 undo log ，从而达到回滚
- 持久性：使用 redo log，从而达到故障后恢复
- 隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行
- 一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。

#### MySQL为什么要用b+树作为索引结构

1. 因为索引文件比较大，内存中是不能一下子存入所有的文件信息的。那么就需要磁盘页的交换。此时就需要尽量的减少磁盘页的换入换出。那么 ，b+树作为一种树形结构能够很好的找到叶子节点上的信息。
2. 相对于b树来说，b+树更加的适合范围查询。因为b+树的数据只存放在叶子节点。而且叶子节点之间还有指针相连，那么就可以直接找到下一个节点。并且，不在非叶子节点中存放数据就使得非叶子节点能够存放更多的信息，这样的话，b+树的高度就更低。

#### 索引失效的情况

以%开头的like查询不能使用B-Tree索引
隐式转换时，当列类型是字符串时候，要是where查询时候没有引起来，就也不会走索引
复合索引情况下不满足最左原则Leftmost,也不会使用复合索引。
如果MySQL估计使用索引比全表扫描更慢，则不使用索引。
以or分割开的条件，如果or前的条件列中有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫面的情况下，就没有必要多一次索引扫面增加I/O访问，一次全表扫描过滤条件就足够了。

#### 一条SQL运行很慢，怎么分析？

分情况来讨论：

- SQL语句一直卡着

  一般可以先用show processlist 来看看当前的语句处于什么状态。

  1. 可能在等待MDL锁。通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的process id，把这个连接用 kill 命令断开即可。（MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10%左右的性能损失)
  2. 等flush
  3. 等行锁

- SQL语句能够返回，就是执行慢

  1. SQL语句查询的列没有索引，所以导致了全表扫描。
  2. 由于另外一个session对某一行数据进行了很多的修改，并且这个修改时在本session启动之后进行的。那么如果在可重复读的隔离条件下，因为要遵循只能够读取到版本号低于自己的。而当前的版本很因为经过很多次的修改（可能是几万次），已经变得很大了。那么，此时就要通过undo log一个一个版本的回溯。于是查询的时间要很长才能返回。

#### 间隙锁会锁哪些行？

- 等值查询且where中的列上有唯一索引

  加锁的基本单位是next-key lock，是一个左开右闭的区间。又因为是等值查询，所以会退化为间隙锁。这里的退化为间隙锁的意思就是只在间隙上加锁。那么，已经在MySQL中的行是不会加锁的。就比如说有5,10这两行的数据。然后去查询7这个不存在的数据，那么在等值查询下，10会退化掉，就是10这行不会被锁。而是锁(5,10)的数据。

#### MySQL主从同步是怎么做的？

一般来说，会把从库设置为只读。但是对于同步更新的线程来说，并没有这个限制。因为这个线程有super权限。主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog。
备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B
的这个长连接。一个事务日志同步的完整过程是这样的：
1. 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及
要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。
2. 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread
和 sql_thread。其中 io_thread 负责与主库建立连接。
3. 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，
发给 B。
4. 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。
5. sql_thread 读取中转日志，解析出日志里的命令，并执行。

#### MySQL的binlog日志格式？

MySQL中binlog一共有三种格式：

row，statement，mixed。

statement格式会记录原来执行的SQL语句。原封不动的记录下来。这种可能会造成主从库不一致的情况。

row是通过event事件来记录的。可以通过mysqlbinlog工具来查看row格式记录的内容。那么这种记录也会把SQL语句修改行的主键id给记录下来，这样去从库执行的时候就不会出现主从不同步的情况了。

mixed是上面两种的混合模式。MySQL会判断该语句是否会出现主从不同步的情况，进而来判断用哪种格式。还有一点就是statement占用的空间小，而row占用空间大。

在通过binlog日志恢复数据的时候要注意将上下文带上，有时候恢复数据时依赖上下文的。 

